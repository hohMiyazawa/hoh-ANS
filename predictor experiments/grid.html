<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Predictor experiments</title>
		<style>
.canvasContainer{
	display: inline-block;
	padding: 5px;
	margin: 5px;
	border: solid;
	border-width: 1px;
	border-radius: 3px;
	max-width: 40%;
}
canvas{
	max-width: 100%;
	max-height: 600px;
	min-width: 16px;
}
body{
	background: rgb(200,200,200);
	padding: 20px;
}
		</style>
		<script src="colourspace.js"></script>
	</head>
	<body>
		<div class="canvasContainer">
			<h2>Original</h2>
			<canvas id="preview" width="0" height="0"></canvas>
		</div>
		<div class="canvasContainer">
			<h2>Current layer</h2>
			<canvas id="render" width="0" height="0"></canvas>
		</div>
		<div class="canvasContainer">
			<h2>Cost estimation</h2>
			<p id="estimate"></p>
			<canvas id="render_cost" width="0" height="0"></canvas>
		</div>
		<hr>
		<h3>Upload</h3>
		<input type="file" id="imageInput"><br>
		<button id="encodeButton">Load</button>
		<h4>Predictors:</h4>
		<div id="parameters"></div>
		<button onclick="tune()">Tune</button>
		<pre id="encodeStats"></pre>
		<script>
let saveByteArray = (function(){
	let a = document.createElement("a");
	document.body.appendChild(a);
	a.style = "display: none";
	return function(data,name){
		let blob = new Blob(data, {type: "octet/stream"});
		let url = window.URL.createObjectURL(blob);
		a.href = url;
		a.download = name;
		a.click();
		window.URL.revokeObjectURL(url)
	}
}())

function readFileAsArrayBuffer(file, success, error) {
	let fr = new FileReader();
	fr.addEventListener('error', error, false);
	if(fr.readAsBinaryString){
		fr.addEventListener('load', function(){
			var string = this.resultString != null ? this.resultString : this.result;
			var result = new Uint8Array(string.length);
			for(var i = 0; i < string.length; i++){
				result[i] = string.charCodeAt(i)
			}
			success(result.buffer)
		}, false);
		return fr.readAsBinaryString(file);
	}
	else {
		fr.addEventListener('load', function(){
			success(this.result)
		}, false);
		return fr.readAsArrayBuffer(file)
	}
}

function drawToCanvas(imageData,id){
	let canvas = document.getElementById(id);
	if(!imageData.imageData){
		return
	}
	canvas.width = imageData.width;
	canvas.height = imageData.height;
	let ctx = canvas.getContext("2d");
	let image = new ImageData(new Uint8ClampedArray(imageData.imageData),imageData.width);
	ctx.putImageData(image,0,0);
}

function drawGreyscale(imageData,width,height){
	let opacity = new Array(imageData.length).fill(0).map(_ => new Array(imageData[0].length).fill(255));
	let image = new ImageData(new Uint8ClampedArray(multiplexChannels([imageData,imageData,imageData,opacity])),width);
	let canvas = document.getElementById("render");
	canvas.width = width;
	canvas.height = height;
	let ctx = canvas.getContext("2d");
	ctx.putImageData(image,0,0);
}

function drawCost(imageData,width,height){
	let opacity = new Array(imageData.length).fill(0).map(_ => new Array(imageData[0].length).fill(255));
	let image = new ImageData(new Uint8ClampedArray(multiplexChannels([imageData,imageData,imageData,opacity])),width);
	let canvas = document.getElementById("render_cost");
	canvas.width = width;
	canvas.height = height;
	let ctx = canvas.getContext("2d");
	ctx.putImageData(image,0,0);
}

let green_channel;

let predictors = [
	{
		name: "FFV1",
		predict: function(L,TL,T,TR){return [T,L,T + L - TL].sort((a,b) => a - b)[1]}
	},
	{
		name: "left",
		predict: function(L,TL,T,TR){return L}
	},
	{
		name: "top",
		predict: function(L,TL,T,TR){return T}
	},
	{
		name: "top-left",
		predict: function(L,TL,T,TR){return TL}
	},
	{
		name: "top-right",
		predict: function(L,TL,T,TR){return TR}
	},
	{
		name: "avg L-T",
		predict: function(L,TL,T,TR){return Math.floor((T + L)/2)}
	},
	{
		name: "avg L-TL",
		predict: function(L,TL,T,TR){return Math.floor((L + TL)/2)}
	},
	{
		name: "avg TL-T",
		predict: function(L,TL,T,TR){return Math.floor((T + TL)/2)}
	},
	{
		name: "avg T-TR",
		predict: function(L,TL,T,TR){return Math.floor((T + TR)/2)}
	},
	{
		name: "avg3 L-L-TL",
		predict: function(L,TL,T,TR){return Math.floor((L + L + TL)/3)}
	},
	{
		name: "avg3 L-TL-TL",
		predict: function(L,TL,T,TR){return Math.floor((L + TL + TL)/3)}
	},
	{
		name: "avg3 TL-TL-T",
		predict: function(L,TL,T,TR){return Math.floor((TL + TL + T)/3)}
	},
	{
		name: "avg3 TL-T-T",
		predict: function(L,TL,T,TR){return Math.floor((TL + T + T)/3)}
	},
	{
		name: "avg3 T-T-TR",
		predict: function(L,TL,T,TR){return Math.floor((T + T + TR)/3)}
	},
	{
		name: "avg3 T-TR-TR",
		predict: function(L,TL,T,TR){return Math.floor((T + TR + TR)/3)}
	},
	{
		name: "avg4",
		predict: function(L,TL,T,TR){return Math.floor((L + TL + T + TR)/4)}
	},
	{
		name: "paeth",
		predict: function(L,TL,T,TR){
			let p = T + L - TL;
			let Tp = Math.abs(T - p);
			let Lp = Math.abs(L - p);
			let TLp = Math.abs(TL - p);
			if(Tp < Lp){
				if(Tp < TLp){
					return T;
				}
				return TL;
			}
			else{
				if(Lp < TLp){
					return L;
				}
				return TL;
			}
		}
	},
	{
		name: "weird",
		predict: function(L,TL,T,TR){return Math.floor((L + TR + 2*T)/4)}
	},
	{
		name: "CAF",
		predict: function(L,TL,T,TR){return Math.min(Math.max(T + L - TL,0),255)}
	},
	{
		name: "CAH",
		predict: function(L,TL,T,TR){return Math.min(Math.max(Math.floor((L+T)/2 + ((L+T)/2 - TL)/2),0),255)}
	}
]

const Stats = {
	average: function(list){
		return list.reduce((a,b) => (a || 0) + (b || 0))/list.length
	},
	median: function(list){
		let temp = [...list].sort((a,b) => a - b);
		return (
			temp[Math.floor((temp.length - 1)/2)]
			+ temp[Math.ceil((temp.length - 1)/2)]
		)/2;
	},
	mode: function(list){
		return [...list].sort(
			(b,a) => list.filter(
				e => e === a
			).length - list.filter(
				e => e === b
			).length
		)[0];
	}
}

function freqs(list){
	let freqs = new Array(256).fill(0);
	list.forEach(value => freqs[value]++)
	return freqs
}
function estimateEntropy(list){
	const freqs = {};
	list.forEach(symbol => {
		freqs[symbol] = (freqs[symbol] || 0) + 1
	})
	let entropy = 0;
	Object.keys(freqs).map(key => freqs[key]).forEach(key => {
		entropy += - key * Math.log2(key/list.length)
	})
	return entropy
}
function estimateEntropy_freqs(freqs){
	let total = freqs.reduce((acc,val) => acc + val,0);
	return freqs.filter(val => val).reduce((acc,val) => acc - Math.log2(val/total) * val,0)
}
function local_estimateEntropy_inclusive(freqs,local_symbols){
	let newFreqs = freqs.map(a => a);
	local_symbols.forEach(symbol => newFreqs[symbol]++);
	let total = newFreqs.reduce((acc,val) => acc + val,0);
	return local_symbols.reduce((acc,val) => acc - Math.log2(newFreqs[val]/total),0)
}
function local_estimateEntropy_exclusive(freqs,local_symbols){//be aware of null symbols!
	let total = freqs.reduce((acc,val) => acc + val,0);
	return local_symbols.reduce((acc,val) => acc - Math.log2(freqs[val]/total),0)
}

function tune(contexts){
	let image_width = green_channel[0].length;
	let image_height = green_channel.length;
	let tile_width = Math.ceil(image_width/8);
	let tile_height = Math.ceil(image_height/8);
	let tile_number = tile_width * tile_height;

	let tile_predictors = new Array(tile_number).fill(0);
	let predictBlock = function(predictor,tile_index){
		let collected = [];
		for(let y=0;y<8;y++){
			let pixel_y = Math.floor(tile_index / tile_width) * 8 + y;
			if(pixel_y >= image_height){
				continue
			}
			for(let x=0;x<8;x++){
				let pixel_x = (tile_index % tile_width) * 8 + x;
				if(pixel_x >= image_width){
					continue
				}
				let VAL = green_channel[
					pixel_y
				][
					pixel_x
				];
				let L;
				let TL;
				let T;
				let TR;
				if(pixel_y === 0){
					TL = 128;
					T = 128;
					TR = 128;
					if(pixel_x === 0){
						L = 128
					}
					else{
						L = green_channel[pixel_y][pixel_x - 1]
					}
				}
				else{
					T = green_channel[pixel_y - 1][pixel_x];
					if(pixel_x === 0){
						L = 128;
						TR = green_channel[pixel_y - 1][pixel_x + 1];
						TL = 128;
					}
					else if(pixel_x === image_width - 1){
						L = green_channel[pixel_y][pixel_x - 1];
						TR = 128;
						TL = green_channel[pixel_y - 1][pixel_x - 1];
					}
					else{
						L = green_channel[pixel_y][pixel_x - 1];
						TR = green_channel[pixel_y - 1][pixel_x + 1];
						TL = green_channel[pixel_y - 1][pixel_x - 1];
					}
				}
				collected.push((VAL - predictors[predictor].predict(L,TL,T,TR) + 256) % 256)
			}
		}
		return collected
	}

	let coded = tile_predictors.map((predictor,index) => predictBlock(predictor,index));

	let entropy = estimateEntropy(coded.flat());
	console.log(entropy/8,"initial");
	let global_table = freqs(coded.flat());
	if(contexts === 1){
		for(let i=0;i<3;i++){
			let new_tiles = [];
			tile_predictors.forEach((tile,index) => {
				let predictor_results = predictors.map((predictor,pIndex) => 
					local_estimateEntropy_inclusive(
						global_table,
						predictBlock(pIndex,index)
					)
				);
				new_tiles.push(predictor_results.indexOf(Math.min(...predictor_results)))
			});
			let coded2 = new_tiles.map((predictor,index) => predictBlock(predictor,index));
			let entropy2 = estimateEntropy(coded2.flat());
			if(entropy2 > entropy){
				break
			}
			entropy = entropy2;
			tile_predictors = new_tiles;
			global_table = freqs(coded2.flat());
			console.log(entropy/8,"secondary");
		}
		let predictorCounts = new Array(predictors.length).fill(0);
		tile_predictors.forEach(predictor => {
			predictorCounts[predictor]++
		})
		console.log((tile_number * 1/3 + estimateEntropy_freqs(predictorCounts))/8,"implied overhead + 1 frequency table");
		console.log("predictors",predictorCounts)
	}
	else if(contexts === 2){
		let heatMap = coded.map(misses => local_estimateEntropy_exclusive(global_table,misses));
		let medianSplitter = Stats.median(heatMap);
		let group_lower = [];
		let group_upper = [];
		coded.forEach((cell,index) => {
			if(heatMap[index] < medianSplitter){
				group_lower.push(cell)
			}
			else{
				group_upper.push(cell)
			}
		});
		let entropy_lower = estimateEntropy(group_lower.flat());
		let entropy_upper = estimateEntropy(group_upper.flat());
		console.log((entropy_lower + entropy_upper)/8,"secondary",group_lower.length,group_upper.length);
		console.log((tile_number * 1/3 + estimateEntropy_freqs([group_lower.length,group_upper.length]))/8,"implied overhead + 2 frequency tables");

		let lower_freqs;
		let upper_freqs;
		for(let i=0;i<5;i++){
			lower_freqs = freqs(group_lower.flat());
			upper_freqs = freqs(group_upper.flat());
			group_lower = [];
			group_upper = [];
			coded.forEach((cell,index) => {
				let if_lower = local_estimateEntropy_inclusive(lower_freqs,cell);
				let if_upper = local_estimateEntropy_inclusive(upper_freqs,cell);
				if(if_lower < if_upper){
					group_lower.push(cell)
				}
				else{
					group_upper.push(cell)
				}
			});
			entropy_lower = estimateEntropy(group_lower.flat());
			entropy_upper = estimateEntropy(group_upper.flat());
			console.log((entropy_lower + entropy_upper)/8,"secondary adjusted " + i,group_lower.length,group_upper.length);
		}
		console.log((tile_number * 1/3 + estimateEntropy_freqs([group_lower.length,group_upper.length]))/8,"implied overhead + 2 frequency tables");

		//predictor search
		for(let i=0;i<3;i++){
			let new_tiles = [];
			tile_predictors.forEach((tile,index) => {
				let predictor_results_lower = predictors.map((predictor,pIndex) => 
					local_estimateEntropy_inclusive(
						lower_freqs,
						predictBlock(pIndex,index)
					)
				);
				let predictor_results_upper = predictors.map((predictor,pIndex) => 
					local_estimateEntropy_inclusive(
						upper_freqs,
						predictBlock(pIndex,index)
					)
				);
				let lower_best = Math.min(...predictor_results_lower);
				let upper_best = Math.min(...predictor_results_upper);
				if(lower_best < upper_best){
					new_tiles.push(predictor_results_lower.indexOf(lower_best))
				}
				else{
					new_tiles.push(predictor_results_upper.indexOf(upper_best))
				}
			});

			let coded2 = new_tiles.map((predictor,index) => predictBlock(predictor,index));

			group_lower = [];
			group_upper = [];
			coded2.forEach((cell,index) => {
				let if_lower = local_estimateEntropy_inclusive(lower_freqs,cell);
				let if_upper = local_estimateEntropy_inclusive(upper_freqs,cell);
				if(if_lower < if_upper){
					group_lower.push(cell)
				}
				else{
					group_upper.push(cell)
				}
			});
			entropy_lower = estimateEntropy(group_lower.flat());
			entropy_upper = estimateEntropy(group_upper.flat());

			let entropy2 = entropy_lower + entropy_upper;
			if(entropy2 > entropy){
				break
			}
			entropy = entropy2;
			tile_predictors = new_tiles;
			lower_freqs = freqs(group_lower.flat());
			upper_freqs = freqs(group_upper.flat());
			console.log(entropy/8,"secondary with search " + i,group_lower.length,group_upper.length);
		}
		let predictorCounts = new Array(predictors.length).fill(0);
		tile_predictors.forEach(predictor => {
			predictorCounts[predictor]++
		})
		console.log((tile_number * 1/3 + estimateEntropy_freqs([group_lower.length,group_upper.length]) + estimateEntropy_freqs(predictorCounts))/8,"implied overhead + 2 frequency tables");
		console.log("predictors",predictorCounts)
	}
	else{
	}
}


const inputElementEncode = document.getElementById("imageInput");
const buttonElementEncode = document.getElementById("encodeButton");

let html_encode = function(){
	if(inputElementEncode.files && inputElementEncode.files[0]){
		let fileName = inputElementEncode.files[0].name;
		let FR = new FileReader();
		FR.onload = function(e){
			let img = new Image();
			img.addEventListener("load", function(){
				let canvas = document.getElementById("preview");
				canvas.height = img.height;
				canvas.width = img.width;
				let ctx = canvas.getContext("2d");
				ctx.drawImage(img, 0, 0);
				let contextData = ctx.getImageData(0,0,img.width,img.height).data;

				let sub_green_data = rgba_to_subgreena(contextData);
				green_channel = deMultiplexChannels(sub_green_data,img.width,img.height)[0];
				drawGreyscale(green_channel,img.width,img.height);
			});
			img.src = e.target.result;
		};
		FR.readAsDataURL(inputElementEncode.files[0]);
	}
}
inputElementEncode.addEventListener("change",html_encode,false);
buttonElementEncode.addEventListener("click",html_encode,false);
		</script>
	</body>
</html>
